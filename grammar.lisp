(in-package :nandtotetris)
(named-readtables:in-readtable rutils-readtable)

;(defvar hdl-file-dictionary (make-hash-table))

(defrule :space (+ (or #\space #\tab #\vt #\cr #\lf)) (:text t))
(defrule :single-quote #\')
(defrule :double-quote #\")
(defrule :period #\.)
(defrule :colon #\:)
(defrule :semi #\;)
(defrule :dollar #\$)
(defrule :comma #\,)
(defrule :lparen #\()
(defrule :rparen #\))
(defrule :lbrace #\{)
(defrule :rbrace #\})
(defrule :lbracket #\[)
(defrule :rbracket #\])
(defrule :equals #\=)
(defrule :newline (or (and #\cr #\lf) #\cr #\lf) (:constant #\lf))
(defrule :eol-comment (and "//" (* (not :newline)) (* :newline)))
(defrule :end-comment "*/")
(defrule :api-comment (and "/**" (* (not :end-comment)) :end-comment))
(defrule :regular-comment (and "/*" (* (not :end-comment)) :end-comment))
(defrule :comment (or :eol-comment :api-comment :regular-comment))
(defrule :ignorable (or :space :comment))
(defrule :file (and (* (not :newline)) (* (and :newline (* (not :newline))))))
(defrule :letter (character-ranges (#\a #\z) (#\A #\Z)))
(defrule :digit (character-ranges (#\0 #\9)))
(defrule :name (and (* :ignorable) (and :letter (* (or :letter :digit))) (* :ignorable)) (:lambda (l) @l#1) (:text t))
(defrule :file-name (and :letter (* (or :letter :digit :dollar :period))) (:error-report nil) (:text t))
(defrule :load-command (and "load" :ignorable :file-name) (:lambda (l) (make 'load-command :file-name @l#2)))
(defrule :output-command "output" (:lambda (l) (declare (ignore l)) (make 'output-command)))
(defrule eval-command (and "eval" (* :ignorable)) (:lambda (l) (declare (ignore l)) (make 'eval-command)))
(defrule :script-command (and (* :ignorable) (or :load-command :eval-command :output-file-command :compare-to-command :set-command :output-command :output-list-command) (* :ignorable))
  (:lambda (l) @l#1)
  )
(defrule :comma-script-command (and comma :script-command) (:lambda (l) @l#1))
(defrule :simulation-step (and :script-command (* comma-script-command) semi) (:lambda (l) (make 'simulation-step :commands (push @l#0 @l#1))))
(defrule :tstfile (+ (and (* ignorable) :simulation-step (* ignorable)))
  (:lambda (l)
    (make-instance 'tstfile :steps (mapcar (lambda (x) @x#1) l))
    )
  )
(defrule :chip-name :name)
(defrule :number (+ digit) (:text t) (:function parse-integer))
(defrule :range (and :number (* :ignorable) ".." (* :ignorable) :number) (:lambda (l) (list @l#0 @l#4)))
(defrule :range-subscript (and :lbracket (* :ignorable) :range (* :ignorable) :rbracket) (:lambda (l) @l#2))
(defrule :subscript (and :lbracket (* :ignorable) :number (* :ignorable) :rbracket) (:lambda (l) @l#2))
(defrule :pin-name (and :name (? :subscript)) (:lambda (l) (list @l#0 (or @l#1 0))))
(defrule :comma-pin-name (and :comma :pin-name) (:lambda (l) @l#1))
(defrule :pin-names (and :pin-name (* :comma-pin-name)) (:lambda (l) (push @l#0 @l#1)))
(defrule :in-line (and "IN" (+ :ignorable) :pin-names (* :ignorable) :semi) (:lambda (l) @l#2))
(defrule :builtin (and "BUILTIN" (+ :ignorable) :chip-name (* :ignorable) :semi) (:lambda (l) (make (find-class (intern (string-upcase (concatenate 'string @l#2 "-gate")))))))
(defrule :complete-pin-name (and :name (? (or :subscript :range-subscript))) (:lambda (l) (if (null @l#1) @l#0 l)))
(defrule :pin-assignment (and :complete-pin-name :equals :complete-pin-name) (:lambda (l) (list @l#0 @l#2)))
(defrule :comma-pin-assignment (and (* :ignorable) :comma (* :ignorable) :pin-assignment) (:lambda (l) @l#3))
(defrule :pin-assignments (and :pin-assignment (* :comma-pin-assignment)) (:lambda (l) (push @l#0 @l#1)))
(defrule :part (and :chip-name (* :ignorable) :lparen (* :ignorable) :pin-assignments :rparen :semi)
  (:destructure (name ign1 lpr ign2 pins rpr sem)
    (declare (ignore ign1 lpr ign2 rpr sem))
    (let* ((chip (parse :hdlfile (slurp (concatenate 'string "/home/fila/" name ".hdl"))))
	   )
      (list chip pins)
      )
    )
  )
(defrule :parts (and "PARTS:" (* :ignorable) (+ :part)) (:lambda (l) (list (make 'composite-gate) @l#2)))
(defrule :out-line (and "OUT" (+ :ignorable) :pin-names (* :ignorable) :semi) (:lambda (l) @l#2))
(defrule :hdlfile (and (* :ignorable) "CHIP" (+ :ignorable) :chip-name (* :ignorable) :lbrace (* :ignorable) :in-line (* :ignorable) :out-line (* :ignorable) (or :parts :builtIn)
		       (* :ignorable) :rbrace (* :ignorable))
  (:lambda (l)
    (let ((inputs (mapcar (lambda (s) (list (mkeyw @s#0) 0)) @l#7))
	  (outputs (mapcar (lambda (s) (list (mkeyw @s#0) 0)) @l#9))
	  (or1 @l#11)
	  )
      (:= (rtl:? @or1.dictionary :inputs) (alist->ht inputs)
	  (rtl:? @or1.dictionary :outputs) (alist->ht outputs)
	  @or1.ports (alist->ht (append inputs outputs))
	  )
      (if (consp or1)
	  (progn
	;; handle the parts which are in the cdr
	    (:= (rtl:? @or1#0.dictionary :inputs) (alist->ht inputs)
		(rtl:? @or1#0.dictionary :outputs) (alist->ht outputs)
		@or1#0.ports (alist->ht (append inputs outputs))
		@or1#0.parts (mapcar (lambda (p) @p#0) @or1#1)
		)
	    )
	  (:= (rtl:? @or1.dictionary :inputs) (alist->ht inputs)
	      (rtl:? @or1.dictionary :outputs) (alist->ht outputs)
	      @or1.ports (alist->ht (append inputs outputs))
	      )
	  )
      @or1
      )
    )
  )
