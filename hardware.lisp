(in-package :cl-user)
(require :esrap)
(require :iterate)

(defpackage nandtotetris
  (:use :cl :esrap :iterate)
  )

(in-package :nandtotetris)

(defclass gate ()
  ((dictionary :accessor dictionary :initarg :dictionary :initform (make-hash-table))
   (ports :accessor ports :initarg :ports :initform (make-hash-table))
   )
  )

(defclass nand-gate (gate)
  (
   )
  )

(defclass composite-gate (gate)
  ((parts :accessor parts :initarg :parts :initform (list))
   )
  )

(defclass port ()
  ((val :accessor val :initarg :val)
   )
  )

(defun nand (a b)
  (not (and a b))
  )

(defgeneric evaluate (self))

(defmethod evaluate ((self nand-gate))
  (with-slots (ports) self
    (setf (val (gethash :out ports)) (nand (val (gethash :a ports)) (val (gethash :b ports))))
    )
  )

(defmethod evaluate ((self composite-gate))
  (dolist (gate (parts self)) (evaluate gate))
  )

(defclass executable ()
  (
   )
  )
(defclass simulation-step (executable)
  ((commands :accessor commands :initarg :commands)
   )
  )
(defclass tstfile (executable)
  ((steps :accessor steps :initarg :steps)
   (chip :accessor chip :initarg :chip)
   (output-file :accessor output-file :initarg :output-file)
   (output-list :accessor output-list :initarg :output-list)
   (compare-file :accessor compare-file :initarg :compare-file)
   )
  )
(defmethod set-contexts ((self tstfile))
  (dolist (step (steps self)) (dolist (command (commands step)) (setf (context command) self)))
  )
(defclass command (executable)
  ((context :accessor context :initarg :context)
   )
  )
(defclass eval-command (command)
  (
   )
  )
(defclass file-command (command)
  ((file-name :accessor file-name :initarg :file-name)
   )
  )
(defclass load-command (file-command)
  (
   )
  )
(defgeneric execute (self &key &allow-other-keys))
(defmethod execute ((self simulation-step) &key)
  (dolist (command (commands self)) (execute command))
  )
(defmethod execute ((self tstfile) &key)
  (dolist (step (steps self)) (execute step))
  )
(defmethod execute ((self load-command) &key)
  (declare (ignore self))
  )
(defmethod execute ((self eval-command) &key)
  (evaluate (chip (context self)))
  )

(defvar hdl-file-dictionary (make-hash-table))

(defrule space (+ (or #\space #\tab #\vt #\cr #\lf)) (:text t))
(defrule single-quote #\')
(defrule double-quote #\")
(defrule period #\.)
(defrule colon #\:)
(defrule semi #\;)
(defrule dollar #\$)
(defrule comma #\,)
(defrule lparen #\()
(defrule rparen #\))
(defrule lbrace #\{)
(defrule rbrace #\})
(defrule lbracket #\[)
(defrule rbracket #\])
(defrule equals #\=)
(defrule newline (or (and #\cr #\lf) #\cr #\lf) (:constant #\lf))
(defrule eol-comment (and "//" (* (not newline)) (* newline)))
(defrule end-comment "*/")
(defrule api-comment (and "/**" (* (not end-comment)) end-comment))
(defrule regular-comment (and "/*" (* (not end-comment)) end-comment))
(defrule comment (or eol-comment api-comment regular-comment))
(defrule ignorable (or space comment))
(defrule file (and (* (not newline)) (* (and newline (* (not newline))))))
(defrule letter (character-ranges (#\a #\z) (#\A #\Z)))
(defrule digit (character-ranges (#\0 #\9)))
(defrule name (and (* ignorable) (and letter (* (or letter digit))) (* ignorable)) (:function (lambda (x) (second x))) (:text t))
(defrule file-name (and letter (* (or letter digit dollar period))) (:error-report nil) (:text t))
(defrule load-command
    (and "load" ignorable file-name)
  (:destructure (command ign file-name)
    (declare (ignore command ign))
    (make-instance 'load-command :file-name file-name)
    ))
(defrule eval-command (and "eval" (* ignorable)) (:lambda (l) (declare (ignore l)) (make-instance 'eval-command)))
(defrule script-command (and (* ignorable) (or load-command eval-command) (* ignorable)) (:function (lambda (x) (second x))))
(defrule comma-script-command (and comma script-command) (:lambda (l) (second l)))
(defrule simulation-step (and script-command (* comma-script-command) semi) (:lambda (x) (make-instance 'simulation-step :commands (push (first x) (second x)))))
(defrule tstfile (+ (and (* ignorable) simulation-step (* ignorable)))
  (:lambda (l)
    (make-instance 'tstfile :steps (mapcar (lambda (x) (second x)) l))
    )
  )
(defrule chip-name name)
(defrule number (+ digit) (:text t) (:function parse-integer))
(defrule range (and number (* ignorable) ".." (* ignorable) number) (:lambda (l) (list (first l) (fifth l))))
(defrule range-subscript (and lbracket (* ignorable) range (* ignorable) rbracket) (:lambda (l) (third l)))
(defrule subscript (and lbracket (* ignorable) number (* ignorable) rbracket) (:lambda (l) (third l)))
(defrule pin-name (and name (? subscript)) (:lambda (l) (if (null (second l)) (first l) l)))
(defrule comma-pin-name (and comma pin-name) (:lambda (l) (second l)))
(defrule pin-names (and pin-name (* comma-pin-name)) (:lambda (l) (push (first l) (second l))))
(defrule in-line (and "IN" (+ ignorable) pin-names (* ignorable) semi) (:lambda (l) (third l)))
(defrule builtin (and "BUILTIN" (+ ignorable) chip-name (* ignorable) semi) (:lambda (l) (list (make-instance (find-class (intern (string-upcase (concatenate 'string (third l) "-gate"))))))))
(defrule complete-pin-name (and name (? (or subscript range-subscript))) (:lambda (l) (if (null (second l)) (first l) l)))
(defrule pin-assignment (and complete-pin-name equals complete-pin-name) (:lambda (l) (list (first l) (third l))))
(defrule comma-pin-assignment (and (* ignorable) comma (* ignorable) pin-assignment) (:lambda (l) (fourth l)))
(defrule pin-assignments (and pin-assignment (* comma-pin-assignment)) (:lambda (l) (push (first l) (second l))))
(defrule part (and chip-name (* ignorable) lparen (* ignorable) pin-assignments rparen semi)
  (:destructure (name ign1 lpr ign2 pins rpr sem)
    (declare (ignore ign1 lpr ign2 rpr sem))
    (let* ((lower-name (string-downcase name))
	   (chip (gethash (intern lower-name) hdl-file-dictionary))
	   )
      (when (null chip)
	(setf chip (parse 'hdlfile (uiop:read-file-string (concatenate 'string "/home/fila/" name ".hdl"))))
	(setf (gethash (intern lower-name) hdl-file-dictionary) chip)
	)
      (list chip pins)
      )
    )
  )
(defrule parts (and "PARTS:" (* ignorable) (+ part)) (:lambda (l) (list (make-instance 'composite-gate) (third l))))
(defrule out-line (and "OUT" (+ ignorable) pin-names (* ignorable) semi) (:lambda (l) (third l)))
(defrule hdlfile (and (* ignorable) "CHIP" (+ ignorable) chip-name (* ignorable) lbrace (* ignorable) in-line (* ignorable) out-line (* ignorable) (or parts builtIn) (* ignorable) rbrace (* ignorable))
  (:destructure (ign1 chip ign2 name ign3 lbr ign4 inl ign5 outl ign6 or1 ign7 rbr ign8)
    (declare (ignore ign1 chip ign2 lbr ign3 ign4 rbr ign5 ign6 ign7 ign8) (ignorable inl outl or1))
    (let ((symbol (intern name (symbol-package :lambda)))
	  (inputs (mapcar (lambda (s) (intern (string-upcase s) (symbol-package :nandtotetris))) inl))
	  (outputs (mapcar (lambda (s) (intern (string-upcase s) (symbol-package :nandtotetris))) outl))
	  )
      (multiple-value-bind (entry found) (gethash symbol hdl-file-dictionary)
	(declare (ignore entry))
	(unless found
	  (setf (gethash symbol hdl-file-dictionary) nil)
	  )
	)
      (setf (gethash :inputs (dictionary or1)) inputs
	    (gethash :outputs (dictionary or1)) outputs
	    (ports or1) (append inputs outputs)
	      )
      or1
      )
    )
  )
